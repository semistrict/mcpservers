
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mcptest: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/semistrict/mcpservers/cmd/mcptest/main.go (0.0%)</option>
				
				<option value="file1">github.com/semistrict/mcpservers/cmd/mcpwrapper/main.go (0.0%)</option>
				
				<option value="file2">github.com/semistrict/mcpservers/pkg/mcpcommon/print_tools.go (0.0%)</option>
				
				<option value="file3">github.com/semistrict/mcpservers/pkg/mcpcommon/tool.go (78.9%)</option>
				
				<option value="file4">github.com/semistrict/mcpservers/servers/tmux/cmd/tmux-mcp/main.go (0.0%)</option>
				
				<option value="file5">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/client.go (69.8%)</option>
				
				<option value="file6">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/send_keys_common.go (52.4%)</option>
				
				<option value="file7">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/server.go (0.0%)</option>
				
				<option value="file8">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_attach.go (3.1%)</option>
				
				<option value="file9">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_bash.go (0.5%)</option>
				
				<option value="file10">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_capture.go (2.8%)</option>
				
				<option value="file11">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_command.go (80.0%)</option>
				
				<option value="file12">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_kill.go (9.1%)</option>
				
				<option value="file13">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_list.go (4.3%)</option>
				
				<option value="file14">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_new_session.go (2.3%)</option>
				
				<option value="file15">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_new_session_common.go (43.2%)</option>
				
				<option value="file16">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_send_control_keys.go (10.0%)</option>
				
				<option value="file17">github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp/tmux_send_keys.go (63.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "os/exec"
        "strconv"
        "strings"
        "sync"
        "time"
)

type MCPRequest struct {
        JSONRPC string      `json:"jsonrpc"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
        ID      interface{} `json:"id"`
}

type MCPResponse struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id,omitempty"`
        Result  interface{} `json:"result,omitempty"`
        Error   interface{} `json:"error,omitempty"`
}

type ToolCall struct {
        Tool string
        Args map[string]interface{}
}

type MCPTester struct {
        cmd    *exec.Cmd
        stdin  io.WriteCloser
        stdout io.ReadCloser
        stderr io.ReadCloser
        mu     sync.Mutex
        nextID int
}

func NewMCPTester(serverCommand string, serverArgs ...string) (*MCPTester, error) <span class="cov0" title="0">{
        cmd := exec.Command(serverCommand, serverArgs...)

        stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov0" title="0">stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov0" title="0">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stderr pipe: %w", err)
        }</span>

        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start server: %w", err)
        }</span>

        <span class="cov0" title="0">tester := &amp;MCPTester{
                cmd:    cmd,
                stdin:  stdin,
                stdout: stdout,
                stderr: stderr,
                nextID: 1,
        }

        // Start stderr reader
        go tester.readStderr()

        return tester, nil</span>
}

func (m *MCPTester) readStderr() <span class="cov0" title="0">{
        scanner := bufio.NewScanner(m.stderr)
        for scanner.Scan() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[SERVER STDERR] %s\n", scanner.Text())
        }</span>
}

func (m *MCPTester) getNextID() int <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        id := m.nextID
        m.nextID++
        return id
}</span>

func (m *MCPTester) sendRequest(method string, params interface{}) (*MCPResponse, error) <span class="cov0" title="0">{
        req := MCPRequest{
                JSONRPC: "2.0",
                Method:  method,
                Params:  params,
                ID:      m.getNextID(),
        }

        reqBytes, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚Üí %s\n", string(reqBytes))

        if _, err := m.stdin.Write(append(reqBytes, '\n')); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write request: %w", err)
        }</span>

        // Read response
        <span class="cov0" title="0">reader := bufio.NewReader(m.stdout)
        line, err := reader.ReadBytes('\n')
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚Üê %s\n", string(line))

        var resp MCPResponse
        if err := json.Unmarshal(line, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

func (m *MCPTester) Initialize() error <span class="cov0" title="0">{
        params := map[string]interface{}{
                "capabilities": map[string]interface{}{},
                "clientInfo": map[string]interface{}{
                        "name":    "mcptest",
                        "version": "1.0.0",
                },
        }

        resp, err := m.sendRequest("initialize", params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initialization failed: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initialization error: %v", resp.Error)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úì Server initialized successfully")
        return nil</span>
}

func (m *MCPTester) ListTools() error <span class="cov0" title="0">{
        resp, err := m.sendRequest("tools/list", nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list tools: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tools/list error: %v", resp.Error)
        }</span>

        // Pretty print tools
        <span class="cov0" title="0">if result, ok := resp.Result.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if tools, ok := result["tools"].([]interface{}); ok </span><span class="cov0" title="0">{
                        fmt.Printf("\nüìã Available Tools (%d):\n", len(tools))
                        for i, tool := range tools </span><span class="cov0" title="0">{
                                if t, ok := tool.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        name := t["name"]
                                        desc := t["description"]
                                        fmt.Printf("  %d. %s - %s\n", i+1, name, desc)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *MCPTester) CallTool(toolCall ToolCall) error <span class="cov0" title="0">{
        params := map[string]interface{}{
                "name":      toolCall.Tool,
                "arguments": toolCall.Args,
        }

        fmt.Printf("üîß Calling tool: %s\n", toolCall.Tool)
        if len(toolCall.Args) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("   Arguments:")
                for k, v := range toolCall.Args </span><span class="cov0" title="0">{
                        fmt.Printf("     %s: %v\n", k, v)
                }</span>
        }

        <span class="cov0" title="0">resp, err := m.sendRequest("tools/call", params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to call tool %s: %w", toolCall.Tool, err)
        }</span>

        <span class="cov0" title="0">if resp.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Tool error: %v\n\n", resp.Error)
                return nil
        }</span>

        // Pretty print result
        <span class="cov0" title="0">if result, ok := resp.Result.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                isError := false
                if errFlag, ok := result["isError"].(bool); ok </span><span class="cov0" title="0">{
                        isError = errFlag
                }</span>

                <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Tool returned error:\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Tool result:\n")
                }</span>

                <span class="cov0" title="0">if content, ok := result["content"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, item := range content </span><span class="cov0" title="0">{
                                if c, ok := item.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if text, ok := c["text"].(string); ok </span><span class="cov0" title="0">{
                                                // Indent the output
                                                lines := strings.Split(text, "\n")
                                                for _, line := range lines </span><span class="cov0" title="0">{
                                                        fmt.Printf("   %s\n", line)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">fmt.Println()
        return nil</span>
}

func (m *MCPTester) Close() error <span class="cov0" title="0">{
        m.stdin.Close()
        m.stdout.Close()
        m.stderr.Close()
        return m.cmd.Wait()
}</span>

// Parse tool calls from simple text format
func parseToolCalls(filename string) ([]ToolCall, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var calls []ToolCall
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse format: tool_name arg1=value1 arg2=value2
                <span class="cov0" title="0">parts := strings.Fields(line)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">call := ToolCall{
                        Tool: parts[0],
                        Args: make(map[string]interface{}),
                }

                for _, part := range parts[1:] </span><span class="cov0" title="0">{
                        if strings.Contains(part, "=") </span><span class="cov0" title="0">{
                                kv := strings.SplitN(part, "=", 2)
                                key := kv[0]
                                value := kv[1]

                                // Try to parse as different types
                                if value == "true" </span><span class="cov0" title="0">{
                                        call.Args[key] = true
                                }</span> else<span class="cov0" title="0"> if value == "false" </span><span class="cov0" title="0">{
                                        call.Args[key] = false
                                }</span> else<span class="cov0" title="0"> if num, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                        call.Args[key] = num
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(value, "[") &amp;&amp; strings.HasSuffix(value, "]") </span><span class="cov0" title="0">{
                                        // Simple array parsing
                                        value = strings.Trim(value, "[]")
                                        if value != "" </span><span class="cov0" title="0">{
                                                items := strings.Split(value, ",")
                                                var array []string
                                                for _, item := range items </span><span class="cov0" title="0">{
                                                        array = append(array, strings.TrimSpace(item))
                                                }</span>
                                                <span class="cov0" title="0">call.Args[key] = array</span>
                                        } else<span class="cov0" title="0"> {
                                                call.Args[key] = []string{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        call.Args[key] = value
                                }</span>
                        }
                }

                <span class="cov0" title="0">calls = append(calls, call)</span>
        }

        <span class="cov0" title="0">return calls, scanner.Err()</span>
}

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s &lt;server-command&gt; [test-file]\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  %s ./tmux-mcp\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s ./tmux-mcp test-calls.txt\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "\nTest file format (one tool call per line):\n")
                fmt.Fprintf(os.Stderr, "  tool_name arg1=value1 arg2=value2\n")
                fmt.Fprintf(os.Stderr, "  tmux_list\n")
                fmt.Fprintf(os.Stderr, "  tmux_new_session command=[echo,hello] prefix=test\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">serverCommand := os.Args[1]
        var testFile string
        if len(os.Args) &gt; 2 </span><span class="cov0" title="0">{
                testFile = os.Args[2]
        }</span>

        <span class="cov0" title="0">fmt.Printf("üöÄ Starting MCP server: %s\n", serverCommand)

        tester, err := NewMCPTester(serverCommand)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start MCP tester: %v", err)
        }</span>
        <span class="cov0" title="0">defer tester.Close()

        // Give server time to start
        time.Sleep(100 * time.Millisecond)

        // Initialize
        if err := tester.Initialize(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize: %v", err)
        }</span>

        // List tools
        <span class="cov0" title="0">if err := tester.ListTools(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list tools: %v", err)
        }</span>

        <span class="cov0" title="0">if testFile != "" </span><span class="cov0" title="0">{
                // Run test file
                fmt.Printf("üìù Running test file: %s\n\n", testFile)
                calls, err := parseToolCalls(testFile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to parse test file: %v", err)
                }</span>

                <span class="cov0" title="0">for i, call := range calls </span><span class="cov0" title="0">{
                        fmt.Printf("--- Test %d ---\n", i+1)
                        if err := tester.CallTool(call); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Test %d failed: %v", i+1, err)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("‚úÖ Completed %d test calls\n", len(calls))</span>
        } else<span class="cov0" title="0"> {
                // Interactive mode
                fmt.Println("üí¨ Interactive mode - enter tool calls (Ctrl+C to exit)")
                fmt.Println("Format: tool_name arg1=value1 arg2=value2")
                fmt.Println()

                scanner := bufio.NewScanner(os.Stdin)
                for </span><span class="cov0" title="0">{
                        fmt.Print("&gt; ")
                        if !scanner.Scan() </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">line := strings.TrimSpace(scanner.Text())
                        if line == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if line == "quit" || line == "exit" </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Parse the line directly
                        <span class="cov0" title="0">parts := strings.Fields(line)
                        if len(parts) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">call := ToolCall{
                                Tool: parts[0],
                                Args: make(map[string]interface{}),
                        }

                        for _, part := range parts[1:] </span><span class="cov0" title="0">{
                                if strings.Contains(part, "=") </span><span class="cov0" title="0">{
                                        kv := strings.SplitN(part, "=", 2)
                                        key := kv[0]
                                        value := kv[1]

                                        // Try to parse as different types
                                        if value == "true" </span><span class="cov0" title="0">{
                                                call.Args[key] = true
                                        }</span> else<span class="cov0" title="0"> if value == "false" </span><span class="cov0" title="0">{
                                                call.Args[key] = false
                                        }</span> else<span class="cov0" title="0"> if num, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                                call.Args[key] = num
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(value, "[") &amp;&amp; strings.HasSuffix(value, "]") </span><span class="cov0" title="0">{
                                                // Simple array parsing
                                                value = strings.Trim(value, "[]")
                                                if value != "" </span><span class="cov0" title="0">{
                                                        items := strings.Split(value, ",")
                                                        var array []string
                                                        for _, item := range items </span><span class="cov0" title="0">{
                                                                array = append(array, strings.TrimSpace(item))
                                                        }</span>
                                                        <span class="cov0" title="0">call.Args[key] = array</span>
                                                } else<span class="cov0" title="0"> {
                                                        call.Args[key] = []string{}
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                call.Args[key] = value
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if err := tester.CallTool(call); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: %v\n", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"
)

type MCPWrapper struct {
        server         *server.MCPServer
        binaryPath     string
        serverArgs     []string
        currentProcess *exec.Cmd
        currentStdin   io.WriteCloser
        currentStdout  io.ReadCloser
        watcher        *fsnotify.Watcher
        mu             sync.RWMutex
        isRestarting   bool
        currentTools   map[string]*mcp.Tool
        requestID      int
        logFile        *os.File
}

type MCPMessage struct {
        JSONRPC string      `json:"jsonrpc"`
        Method  string      `json:"method,omitempty"`
        Params  interface{} `json:"params,omitempty"`
        Result  interface{} `json:"result,omitempty"`
        Error   interface{} `json:"error,omitempty"`
        ID      interface{} `json:"id,omitempty"`
}

func NewMCPWrapper(binaryPath string, serverArgs ...string) (*MCPWrapper, error) <span class="cov0" title="0">{
        absPath, err := filepath.Abs(binaryPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        <span class="cov0" title="0">wrapper := &amp;MCPWrapper{
                binaryPath:   absPath,
                serverArgs:   serverArgs,
                currentTools: make(map[string]*mcp.Tool),
        }

        // Set up logging if MCPWRAPPER_LOG_FILE is set
        if logPath := os.Getenv("MCPWRAPPER_LOG_FILE"); logPath != "" </span><span class="cov0" title="0">{
                logFile, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open log file %s: %w", logPath, err)
                }</span>
                <span class="cov0" title="0">wrapper.logFile = logFile
                wrapper.logEvent("WRAPPER_START", "MCP Wrapper started", map[string]interface{}{
                        "binary_path": absPath,
                        "server_args": serverArgs,
                })</span>
        }

        // Create the wrapper MCP server
        <span class="cov0" title="0">wrapper.server = server.NewMCPServer("mcpwrapper", "1.0.0")

        // Set up file watcher
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create watcher: %w", err)
        }</span>
        <span class="cov0" title="0">wrapper.watcher = watcher

        // Add the binary file to watcher
        if err := watcher.Add(absPath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to watch binary: %w", err)
        }</span>

        <span class="cov0" title="0">return wrapper, nil</span>
}

func (w *MCPWrapper) Start() error <span class="cov0" title="0">{
        // Start watching for file changes
        go w.watchFileChanges()

        // Start the underlying server initially
        if err := w.startUnderlyingServer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start underlying server: %w", err)
        }</span>

        // Load initial tools
        <span class="cov0" title="0">if err := w.loadToolsFromServer(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to load initial tools: %v", err)
        }</span>

        // Start the wrapper MCP server
        <span class="cov0" title="0">return server.ServeStdio(w.server)</span>
}

func (w *MCPWrapper) watchFileChanges() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case event, ok := &lt;-w.watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if event.Has(fsnotify.Write) || event.Has(fsnotify.Create) </span><span class="cov0" title="0">{
                                log.Printf("Binary changed: %s", event.Name)
                                w.logEvent("BINARY_CHANGED", "Detected binary file change", map[string]interface{}{
                                        "file_path": event.Name,
                                        "operation": event.Op.String(),
                                })

                                // Small delay to ensure write is complete
                                time.Sleep(100 * time.Millisecond)

                                if err := w.restartServer(); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to restart server: %v", err)
                                        w.logEvent("RESTART_FAILED", "Server restart failed", map[string]interface{}{
                                                "error": err.Error(),
                                        })
                                }</span>
                        }

                case err, ok := &lt;-w.watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("Watcher error: %v", err)
                        w.logEvent("WATCHER_ERROR", "File watcher error", map[string]interface{}{
                                "error": err.Error(),
                        })</span>
                }
        }
}

func (w *MCPWrapper) startUnderlyingServer() error <span class="cov0" title="0">{
        w.mu.Lock()
        defer w.mu.Unlock()

        cmd := exec.Command(w.binaryPath, w.serverArgs...)

        stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov0" title="0">stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>

        <span class="cov0" title="0">w.currentProcess = cmd
        w.currentStdin = stdin
        w.currentStdout = stdout

        log.Printf("Started underlying server: PID %d", cmd.Process.Pid)
        return nil</span>
}

func (w *MCPWrapper) stopUnderlyingServer() error <span class="cov0" title="0">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if w.currentProcess == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Close pipes
        <span class="cov0" title="0">if w.currentStdin != nil </span><span class="cov0" title="0">{
                w.currentStdin.Close()
        }</span>
        <span class="cov0" title="0">if w.currentStdout != nil </span><span class="cov0" title="0">{
                w.currentStdout.Close()
        }</span>

        // Kill process
        <span class="cov0" title="0">if err := w.currentProcess.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to kill process: %v", err)
        }</span>

        // Wait for it to exit
        <span class="cov0" title="0">w.currentProcess.Wait()
        w.currentProcess = nil
        w.currentStdin = nil
        w.currentStdout = nil

        log.Printf("Stopped underlying server")
        return nil</span>
}

func (w *MCPWrapper) restartServer() error <span class="cov0" title="0">{
        w.mu.Lock()
        w.isRestarting = true
        w.mu.Unlock()

        defer func() </span><span class="cov0" title="0">{
                w.mu.Lock()
                w.isRestarting = false
                w.mu.Unlock()
        }</span>()

        <span class="cov0" title="0">log.Printf("Restarting server due to binary change...")
        w.logEvent("SERVER_RESTART_START", "Server restart initiated due to binary change", nil)

        // Remove all current tools
        w.removeAllTools()

        // Stop current server
        if err := w.stopUnderlyingServer(); err != nil </span><span class="cov0" title="0">{
                w.logEvent("SERVER_RESTART_ERROR", "Failed to stop server during restart", map[string]interface{}{
                        "error": err.Error(),
                })
                return fmt.Errorf("failed to stop server: %w", err)
        }</span>

        // Start new server
        <span class="cov0" title="0">if err := w.startUnderlyingServer(); err != nil </span><span class="cov0" title="0">{
                w.logEvent("SERVER_RESTART_ERROR", "Failed to start new server during restart", map[string]interface{}{
                        "error": err.Error(),
                })
                return fmt.Errorf("failed to start new server: %w", err)
        }</span>

        // Load new tools
        <span class="cov0" title="0">if err := w.loadToolsFromServer(); err != nil </span><span class="cov0" title="0">{
                w.logEvent("SERVER_RESTART_ERROR", "Failed to load tools during restart", map[string]interface{}{
                        "error": err.Error(),
                })
                return fmt.Errorf("failed to load new tools: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Server restart completed successfully")
        w.logEvent("SERVER_RESTART_COMPLETE", "Server restart completed successfully", nil)
        return nil</span>
}

func (w *MCPWrapper) removeAllTools() <span class="cov0" title="0">{
        w.mu.Lock()
        defer w.mu.Unlock()

        // Get list of current tool names
        var toolNames []string
        for name := range w.currentTools </span><span class="cov0" title="0">{
                toolNames = append(toolNames, name)
        }</span>

        <span class="cov0" title="0">if len(toolNames) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Removing %d tools: %v", len(toolNames), toolNames)
                w.logEvent("TOOLS_REMOVED", fmt.Sprintf("Removed %d tools", len(toolNames)), map[string]interface{}{
                        "count":      len(toolNames),
                        "tool_names": toolNames,
                })
                w.server.DeleteTools(toolNames...)
                w.currentTools = make(map[string]*mcp.Tool)
        }</span>
}

func (w *MCPWrapper) loadToolsFromServer() error <span class="cov0" title="0">{
        w.mu.Lock()
        defer w.mu.Unlock()

        // Initialize the underlying server
        initReq := MCPMessage{
                JSONRPC: "2.0",
                Method:  "initialize",
                Params: map[string]interface{}{
                        "capabilities": map[string]interface{}{},
                        "clientInfo": map[string]interface{}{
                                "name":    "mcpwrapper",
                                "version": "1.0.0",
                        },
                },
                ID: w.getNextRequestID(),
        }

        if err := w.sendToServer(initReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send initialize: %w", err)
        }</span>

        // Read initialize response
        <span class="cov0" title="0">if _, err := w.readFromServer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read initialize response: %w", err)
        }</span>

        // List tools
        <span class="cov0" title="0">listReq := MCPMessage{
                JSONRPC: "2.0",
                Method:  "tools/list",
                ID:      w.getNextRequestID(),
        }

        if err := w.sendToServer(listReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send tools/list: %w", err)
        }</span>

        // Read tools/list response
        <span class="cov0" title="0">resp, err := w.readFromServer()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read tools/list response: %w", err)
        }</span>

        // Parse tools from response
        <span class="cov0" title="0">if err := w.parseAndAddTools(resp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse tools: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (w *MCPWrapper) sendToServer(msg MCPMessage) error <span class="cov0" title="0">{
        if w.currentStdin == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server not running")
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        <span class="cov0" title="0">if _, err := w.currentStdin.Write(append(data, '\n')); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to server: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (w *MCPWrapper) readFromServer() (*MCPMessage, error) <span class="cov0" title="0">{
        if w.currentStdout == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server not running")
        }</span>

        <span class="cov0" title="0">reader := bufio.NewReader(w.currentStdout)
        line, err := reader.ReadBytes('\n')
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read from server: %w", err)
        }</span>

        <span class="cov0" title="0">var msg MCPMessage
        if err := json.Unmarshal(line, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal message: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;msg, nil</span>
}

func (w *MCPWrapper) parseAndAddTools(resp *MCPMessage) error <span class="cov0" title="0">{
        if resp.Result == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no result in tools/list response")
        }</span>

        <span class="cov0" title="0">result, ok := resp.Result.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid result format")
        }</span>

        <span class="cov0" title="0">toolsData, ok := result["tools"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no tools in result")
        }</span>

        <span class="cov0" title="0">log.Printf("Loading %d tools from server", len(toolsData))
        w.logEvent("TOOLS_LOADING", fmt.Sprintf("Loading %d tools from server", len(toolsData)), map[string]interface{}{
                "count": len(toolsData),
        })

        var addedTools []string
        for _, toolData := range toolsData </span><span class="cov0" title="0">{
                toolMap, ok := toolData.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract tool information
                <span class="cov0" title="0">name, _ := toolMap["name"].(string)
                description, _ := toolMap["description"].(string)

                if name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create tool for wrapper with full schema
                <span class="cov0" title="0">toolOptions := []mcp.ToolOption{mcp.WithDescription(description)}

                // Preserve the original input schema if available
                if inputSchema, ok := toolMap["inputSchema"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Add parameters from the original schema
                        if properties, ok := inputSchema["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if required, ok := inputSchema["required"].([]interface{}); ok </span><span class="cov0" title="0">{
                                        requiredSet := make(map[string]bool)
                                        for _, r := range required </span><span class="cov0" title="0">{
                                                if reqStr, ok := r.(string); ok </span><span class="cov0" title="0">{
                                                        requiredSet[reqStr] = true
                                                }</span>
                                        }

                                        <span class="cov0" title="0">for paramName, paramDef := range properties </span><span class="cov0" title="0">{
                                                if paramMap, ok := paramDef.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                        paramType, _ := paramMap["type"].(string)
                                                        paramDesc, _ := paramMap["description"].(string)
                                                        isRequired := requiredSet[paramName]

                                                        switch paramType </span>{
                                                        case "string":<span class="cov0" title="0">
                                                                opts := []mcp.PropertyOption{mcp.Description(paramDesc)}
                                                                if isRequired </span><span class="cov0" title="0">{
                                                                        opts = append(opts, mcp.Required())
                                                                }</span>
                                                                <span class="cov0" title="0">toolOptions = append(toolOptions, mcp.WithString(paramName, opts...))</span>
                                                        case "boolean":<span class="cov0" title="0">
                                                                opts := []mcp.PropertyOption{mcp.Description(paramDesc)}
                                                                if isRequired </span><span class="cov0" title="0">{
                                                                        opts = append(opts, mcp.Required())
                                                                }</span>
                                                                <span class="cov0" title="0">toolOptions = append(toolOptions, mcp.WithBoolean(paramName, opts...))</span>
                                                        case "number":<span class="cov0" title="0">
                                                                opts := []mcp.PropertyOption{mcp.Description(paramDesc)}
                                                                if isRequired </span><span class="cov0" title="0">{
                                                                        opts = append(opts, mcp.Required())
                                                                }</span>
                                                                <span class="cov0" title="0">toolOptions = append(toolOptions, mcp.WithNumber(paramName, opts...))</span>
                                                        case "array":<span class="cov0" title="0">
                                                                opts := []mcp.PropertyOption{mcp.Description(paramDesc)}
                                                                if isRequired </span><span class="cov0" title="0">{
                                                                        opts = append(opts, mcp.Required())
                                                                }</span>
                                                                <span class="cov0" title="0">toolOptions = append(toolOptions, mcp.WithArray(paramName, opts...))</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">tool := mcp.NewTool(name, toolOptions...)

                // Create handler that proxies to underlying server
                handler := w.createProxyHandler(name)

                // Add tool to wrapper
                w.server.AddTool(tool, handler)
                w.currentTools[name] = &amp;tool
                addedTools = append(addedTools, name)

                log.Printf("Added tool: %s", name)</span>
        }

        <span class="cov0" title="0">if len(addedTools) &gt; 0 </span><span class="cov0" title="0">{
                w.logEvent("TOOLS_ADDED", fmt.Sprintf("Added %d tools", len(addedTools)), map[string]interface{}{
                        "count":      len(addedTools),
                        "tool_names": addedTools,
                })
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (w *MCPWrapper) createProxyHandler(toolName string) func(context.Context, mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                // Log the tool call
                args := req.GetArguments()
                w.logEvent("TOOL_CALL", fmt.Sprintf("Tool '%s' called", toolName), map[string]interface{}{
                        "tool_name": toolName,
                        "arguments": args,
                })

                w.mu.RLock()
                isRestarting := w.isRestarting
                w.mu.RUnlock()

                if isRestarting </span><span class="cov0" title="0">{
                        result := &amp;mcp.CallToolResult{
                                Content: []mcp.Content{
                                        mcp.TextContent{
                                                Type: "text",
                                                Text: "Server is restarting, please try again in a moment",
                                        },
                                },
                                IsError: true,
                        }
                        w.logEvent("TOOL_RESULT", fmt.Sprintf("Tool '%s' failed (server restarting)", toolName), map[string]interface{}{
                                "tool_name": toolName,
                                "error":     true,
                        })
                        return result, nil
                }</span>

                // Forward request to underlying server
                <span class="cov0" title="0">forwardReq := MCPMessage{
                        JSONRPC: "2.0",
                        Method:  "tools/call",
                        Params: map[string]interface{}{
                                "name":      toolName,
                                "arguments": req.GetArguments(),
                        },
                        ID: w.getNextRequestID(),
                }

                w.mu.RLock()
                defer w.mu.RUnlock()

                if err := w.sendToServer(forwardReq); err != nil </span><span class="cov0" title="0">{
                        result := &amp;mcp.CallToolResult{
                                Content: []mcp.Content{
                                        mcp.TextContent{
                                                Type: "text",
                                                Text: fmt.Sprintf("Failed to forward request: %v", err),
                                        },
                                },
                                IsError: true,
                        }
                        w.logEvent("TOOL_RESULT", fmt.Sprintf("Tool '%s' failed (forward error)", toolName), map[string]interface{}{
                                "tool_name": toolName,
                                "error":     true,
                                "reason":    err.Error(),
                        })
                        return result, nil
                }</span>

                // Read response
                <span class="cov0" title="0">resp, err := w.readFromServer()
                if err != nil </span><span class="cov0" title="0">{
                        result := &amp;mcp.CallToolResult{
                                Content: []mcp.Content{
                                        mcp.TextContent{
                                                Type: "text",
                                                Text: fmt.Sprintf("Failed to read response: %v", err),
                                        },
                                },
                                IsError: true,
                        }
                        w.logEvent("TOOL_RESULT", fmt.Sprintf("Tool '%s' failed (read error)", toolName), map[string]interface{}{
                                "tool_name": toolName,
                                "error":     true,
                                "reason":    err.Error(),
                        })
                        return result, nil
                }</span>

                // Convert response to CallToolResult
                <span class="cov0" title="0">result, convErr := w.convertToCallToolResult(resp)

                // Log the result
                if result.IsError </span><span class="cov0" title="0">{
                        w.logEvent("TOOL_RESULT", fmt.Sprintf("Tool '%s' completed with error", toolName), map[string]interface{}{
                                "tool_name": toolName,
                                "error":     true,
                        })
                }</span> else<span class="cov0" title="0"> {
                        w.logEvent("TOOL_RESULT", fmt.Sprintf("Tool '%s' completed successfully", toolName), map[string]interface{}{
                                "tool_name": toolName,
                                "error":     false,
                        })
                }</span>

                <span class="cov0" title="0">return result, convErr</span>
        }
}

func (w *MCPWrapper) convertToCallToolResult(resp *MCPMessage) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        if resp.Error != nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: fmt.Sprintf("Tool error: %v", resp.Error),
                                },
                        },
                        IsError: true,
                }, nil
        }</span>

        <span class="cov0" title="0">if resp.Result == nil </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: "No result from tool",
                                },
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">result, ok := resp.Result.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: fmt.Sprintf("Invalid result format: %v", resp.Result),
                                },
                        },
                }, nil
        }</span>

        // Extract content
        <span class="cov0" title="0">var content []mcp.Content
        if contentData, ok := result["content"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, item := range contentData </span><span class="cov0" title="0">{
                        if itemMap, ok := item.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if text, ok := itemMap["text"].(string); ok </span><span class="cov0" title="0">{
                                        content = append(content, mcp.TextContent{
                                                Type: "text",
                                                Text: text,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">isError := false
        if errFlag, ok := result["isError"].(bool); ok </span><span class="cov0" title="0">{
                isError = errFlag
        }</span>

        <span class="cov0" title="0">return &amp;mcp.CallToolResult{
                Content: content,
                IsError: isError,
        }, nil</span>
}

func (w *MCPWrapper) getNextRequestID() int <span class="cov0" title="0">{
        w.requestID++
        return w.requestID
}</span>

func (w *MCPWrapper) logEvent(eventType, message string, details map[string]interface{}) <span class="cov0" title="0">{
        if w.logFile == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">timestamp := time.Now().Format("2006-01-02 15:04:05.000")
        logEntry := fmt.Sprintf("[%s] %s: %s", timestamp, eventType, message)

        if details != nil </span><span class="cov0" title="0">{
                var detailStrings []string
                for key, value := range details </span><span class="cov0" title="0">{
                        detailStrings = append(detailStrings, fmt.Sprintf("%s=%v", key, value))
                }</span>
                <span class="cov0" title="0">if len(detailStrings) &gt; 0 </span><span class="cov0" title="0">{
                        logEntry += fmt.Sprintf(" (%s)", strings.Join(detailStrings, ", "))
                }</span>
        }

        <span class="cov0" title="0">logEntry += "\n"
        w.logFile.WriteString(logEntry)
        w.logFile.Sync()</span> // Ensure it's written immediately
}

func (w *MCPWrapper) Close() error <span class="cov0" title="0">{
        if w.logFile != nil </span><span class="cov0" title="0">{
                w.logEvent("WRAPPER_STOP", "MCP Wrapper stopping", nil)
                w.logFile.Close()
        }</span>
        <span class="cov0" title="0">if w.watcher != nil </span><span class="cov0" title="0">{
                w.watcher.Close()
        }</span>
        <span class="cov0" title="0">return w.stopUnderlyingServer()</span>
}

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s &lt;mcp-server-binary&gt; [args...]\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "\nThis wrapper monitors the MCP server binary for changes and automatically\n")
                fmt.Fprintf(os.Stderr, "restarts it, updating the tool list dynamically.\n")
                fmt.Fprintf(os.Stderr, "\nEnvironment Variables:\n")
                fmt.Fprintf(os.Stderr, "  MCPWRAPPER_LOG_FILE    Path to log file for detailed human-readable logging\n")
                fmt.Fprintf(os.Stderr, "\nExample:\n")
                fmt.Fprintf(os.Stderr, "  %s ./tmux-mcp\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  MCPWRAPPER_LOG_FILE=/tmp/wrapper.log %s ./tmux-mcp\n", os.Args[0])
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">binaryPath := os.Args[1]
        serverArgs := os.Args[2:]

        wrapper, err := NewMCPWrapper(binaryPath, serverArgs...)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create wrapper: %v", err)
        }</span>
        <span class="cov0" title="0">defer wrapper.Close()

        log.Printf("Starting MCP wrapper for: %s %v", binaryPath, serverArgs)

        if err := wrapper.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Wrapper failed: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mcpcommon

import (
        "fmt"
        "github.com/mark3labs/mcp-go/server"
        "sort"
)

func PrintTools(tools []server.ServerTool) <span class="cov0" title="0">{
        // Sort tools by name for consistent output
        sortedTools := make([]server.ServerTool, len(tools))
        copy(sortedTools, tools)
        sort.Slice(sortedTools, func(i, j int) bool </span><span class="cov0" title="0">{
                return sortedTools[i].Tool.Name &lt; sortedTools[j].Tool.Name
        }</span>)

        <span class="cov0" title="0">for _, serverTool := range sortedTools </span><span class="cov0" title="0">{
                tool := serverTool.Tool
                fmt.Printf("Tool: %s\n", tool.Name)
                if tool.Description != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  Description: %s\n", tool.Description)
                }</span>

                // Print parameters
                <span class="cov0" title="0">if tool.InputSchema.Properties != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Parameters:\n")

                        // Sort properties for consistent output
                        var propNames []string
                        for name := range tool.InputSchema.Properties </span><span class="cov0" title="0">{
                                propNames = append(propNames, name)
                        }</span>
                        <span class="cov0" title="0">sort.Strings(propNames)

                        for _, name := range propNames </span><span class="cov0" title="0">{
                                prop := tool.InputSchema.Properties[name]
                                required := false
                                if tool.InputSchema.Required != nil </span><span class="cov0" title="0">{
                                        for _, req := range tool.InputSchema.Required </span><span class="cov0" title="0">{
                                                if req == name </span><span class="cov0" title="0">{
                                                        required = true
                                                        break</span>
                                                }
                                        }
                                }

                                <span class="cov0" title="0">requiredStr := ""
                                if required </span><span class="cov0" title="0">{
                                        requiredStr = " (required)"
                                }</span>

                                // Try to extract type and description from the property (it's a map)
                                <span class="cov0" title="0">typeStr := ""
                                descStr := ""
                                if propMap, ok := prop.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if propType, exists := propMap["type"]; exists </span><span class="cov0" title="0">{
                                                if typeVal, ok := propType.(string); ok </span><span class="cov0" title="0">{
                                                        typeStr = fmt.Sprintf(" [%s]", typeVal)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if propDesc, exists := propMap["description"]; exists </span><span class="cov0" title="0">{
                                                if descVal, ok := propDesc.(string); ok </span><span class="cov0" title="0">{
                                                        descStr = descVal
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">fmt.Printf("    %s%s%s", name, typeStr, requiredStr)
                                if descStr != "" </span><span class="cov0" title="0">{
                                        fmt.Printf(" - %s", descStr)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                } else<span class="cov0" title="0"> {
                        fmt.Printf("  Parameters: none\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package mcpcommon

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"
        "reflect"
        "strconv"
        "strings"
)

func ReflectTool[T ToolHandler]() server.ServerTool <span class="cov8" title="1">{
        var example T
        toolType := reflect.TypeOf(example)

        // If T is a pointer type, get the element type
        if toolType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                toolType = toolType.Elem()
        }</span>

        // Get tool metadata from ToolInfo field
        <span class="cov8" title="1">toolName, toolTitle, toolDescription, isDestructive, isReadOnly := parseToolInfo(toolType)

        // Create the tool with basic info
        options := []mcp.ToolOption{
                mcp.WithDescription(toolDescription),
                mcp.WithDestructiveHintAnnotation(isDestructive),
                mcp.WithReadOnlyHintAnnotation(isReadOnly),
        }

        // Add title if provided
        if toolTitle != "" </span><span class="cov0" title="0">{
                options = append(options, mcp.WithTitleAnnotation(toolTitle))
        }</span>

        // Add properties from struct fields
        <span class="cov8" title="1">options = append(options, parseToolProperties(toolType)...)

        tool := mcp.NewTool(toolName, options...)

        return server.ServerTool{
                Tool: tool,
                Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov8" title="1">{
                        // Create new instance and populate from request arguments
                        var toolInstance T

                        // Handle both pointer and value types
                        originalType := reflect.TypeOf(toolInstance)
                        if originalType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                // T is already a pointer type
                                toolInstance = reflect.New(originalType.Elem()).Interface().(T)
                        }</span> else<span class="cov0" title="0"> {
                                // T is a value type, create a pointer to it
                                ptr := reflect.New(originalType)
                                toolInstance = ptr.Interface().(T)
                        }</span>

                        // Unmarshal arguments into the tool struct
                        <span class="cov8" title="1">if err := unmarshalArguments(toolInstance, request.GetArguments()); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal arguments: %v", err)
                        }</span>

                        // Call the handler
                        <span class="cov8" title="1">result, err := toolInstance.Handle(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Convert result to CallToolResult
                        <span class="cov8" title="1">return convertResult(result), nil</span>
                },
        }
}

func parseToolInfo(toolType reflect.Type) (name, title, description string, destructive, readonly bool) <span class="cov8" title="1">{
        for i := 0; i &lt; toolType.NumField(); i++ </span><span class="cov8" title="1">{
                field := toolType.Field(i)
                if field.Type == reflect.TypeOf(ToolInfo{}) </span><span class="cov8" title="1">{
                        name = field.Tag.Get("name")
                        title = field.Tag.Get("title")
                        description = field.Tag.Get("description")
                        destructive = field.Tag.Get("destructive") == "true"
                        readonly = field.Tag.Get("readonly") == "true"
                        return
                }</span>
        }

        // Fallback to type name if no ToolInfo found
        <span class="cov0" title="0">name = strings.ToLower(toolType.Name())
        description = "Tool generated from " + toolType.Name()
        return</span>
}

func parseToolProperties(toolType reflect.Type) []mcp.ToolOption <span class="cov8" title="1">{
        var options []mcp.ToolOption

        for i := 0; i &lt; toolType.NumField(); i++ </span><span class="cov8" title="1">{
                field := toolType.Field(i)

                // Skip ToolInfo fields and unexported fields
                if field.Type == reflect.TypeOf(ToolInfo{}) || !field.IsExported() </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Skip embedded structs - we'll handle their fields recursively
                <span class="cov8" title="1">if field.Anonymous </span><span class="cov0" title="0">{
                        options = append(options, parseToolProperties(field.Type)...)
                        continue</span>
                }

                <span class="cov8" title="1">jsonTag := field.Tag.Get("json")
                if jsonTag == "" || jsonTag == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fieldName := strings.Split(jsonTag, ",")[0]
                description := field.Tag.Get("description")
                required := field.Tag.Get("mcp") == "required"
                defaultValue := field.Tag.Get("default")

                // Validate that description doesn't contain "default:" - should use separate tag
                if strings.Contains(strings.ToLower(description), "default:") </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("Field %s.%s: description contains 'default:' - use separate 'default' struct tag instead",
                                toolType.Name(), field.Name))</span>
                }

                // Add property based on field type
                <span class="cov8" title="1">switch field.Type.Kind() </span>{
                case reflect.String:<span class="cov8" title="1">
                        var paramOptions []mcp.PropertyOption
                        paramOptions = append(paramOptions, mcp.Description(description))
                        if required </span><span class="cov8" title="1">{
                                paramOptions = append(paramOptions, mcp.Required())
                        }</span>
                        <span class="cov8" title="1">if defaultValue != "" </span><span class="cov8" title="1">{
                                paramOptions = append(paramOptions, mcp.DefaultString(defaultValue))
                        }</span>
                        <span class="cov8" title="1">options = append(options, mcp.WithString(fieldName, paramOptions...))</span>

                case reflect.Bool:<span class="cov8" title="1">
                        var paramOptions []mcp.PropertyOption
                        paramOptions = append(paramOptions, mcp.Description(description))
                        if defaultValue != "" </span><span class="cov8" title="1">{
                                if defaultValue == "true" </span><span class="cov8" title="1">{
                                        paramOptions = append(paramOptions, mcp.DefaultBool(true))
                                }</span> else<span class="cov0" title="0"> if defaultValue == "false" </span><span class="cov0" title="0">{
                                        paramOptions = append(paramOptions, mcp.DefaultBool(false))
                                }</span>
                        }
                        <span class="cov8" title="1">options = append(options, mcp.WithBoolean(fieldName, paramOptions...))</span>

                case reflect.Int, reflect.Int64, reflect.Float64:<span class="cov8" title="1">
                        var paramOptions []mcp.PropertyOption
                        paramOptions = append(paramOptions, mcp.Description(description))
                        if required </span><span class="cov8" title="1">{
                                paramOptions = append(paramOptions, mcp.Required())
                        }</span>
                        <span class="cov8" title="1">if defaultValue != "" </span><span class="cov8" title="1">{
                                if defaultNum, err := strconv.ParseFloat(defaultValue, 64); err == nil </span><span class="cov8" title="1">{
                                        paramOptions = append(paramOptions, mcp.DefaultNumber(defaultNum))
                                }</span>
                        }
                        <span class="cov8" title="1">options = append(options, mcp.WithNumber(fieldName, paramOptions...))</span>
                case reflect.Slice:<span class="cov8" title="1">
                        if field.Type.Elem().Kind() == reflect.String </span><span class="cov8" title="1">{
                                // Array of strings - specify items as string type
                                options = append(options, mcp.WithArray(fieldName,
                                        mcp.Description(description),
                                        mcp.WithStringItems(),
                                ))
                        }</span>
                }
        }

        <span class="cov8" title="1">return options</span>
}

func unmarshalArguments(tool interface{}, arguments map[string]interface{}) error <span class="cov8" title="1">{
        // Convert arguments to JSON and back to populate the struct
        jsonData, err := json.Marshal(arguments)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return json.Unmarshal(jsonData, tool)</span>
}

func convertResult(result interface{}) *mcp.CallToolResult <span class="cov8" title="1">{
        switch v := result.(type) </span>{
        case string:<span class="cov8" title="1">
                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: v,
                                },
                        },
                }</span>
        case *mcp.CallToolResult:<span class="cov0" title="0">
                return v</span>
        default:<span class="cov0" title="0">
                // Marshal to JSON and return as text
                data, err := json.MarshalIndent(result, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;mcp.CallToolResult{
                                Content: []mcp.Content{
                                        mcp.TextContent{
                                                Type: "text",
                                                Text: fmt.Sprintf("Error marshaling result: %v", err),
                                        },
                                },
                                IsError: true,
                        }
                }</span>
                <span class="cov0" title="0">return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: string(data),
                                },
                        },
                }</span>
        }
}

// ToolHandler implements a tool.
type ToolHandler interface {
        Handle(ctx context.Context) (interface{}, error)
}

// ToolInfo is uses as the type of dummy field to annotate the tool itself with struct tags.
type ToolInfo struct{}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "flag"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
        "log"
        "os"

        "github.com/semistrict/mcpservers/servers/tmux/pkg/tmuxmcp"
)

func main() <span class="cov0" title="0">{
        var help bool
        flag.BoolVar(&amp;help, "h", false, "Show available tools and their arguments")
        flag.Parse()

        if help </span><span class="cov0" title="0">{
                fmt.Println("tmux-mcp - MCP server for tmux session management")
                fmt.Println()
                fmt.Println("Usage:")
                fmt.Println("  tmux-mcp       Start the MCP server (communicates via stdio)")
                fmt.Println("  tmux-mcp -h    Show this help message")
                fmt.Println()
                fmt.Println("Available tools:")
                fmt.Println()
                mcpcommon.PrintTools(tmuxmcp.Tools)
                return
        }</span>

        <span class="cov0" title="0">if err := tmuxmcp.Run(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Server error: %v", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package tmuxmcp

import (
        "context"
        "crypto/sha256"
        "fmt"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"
)

// testSocketPath is used for testing to override the default tmux socket
var testSocketPath string

// Options structs
type captureOptions struct {
        Prefix string
}

type captureResult struct {
        SessionName string
        Output      string
        Hash        string
}

type cursorResult struct {
        SessionName string
        CursorLine  string
        CursorY     int
        CursorX     int
        Output      string
        Hash        string
}

// Constants
const (
        expectWaitTimeout  = 60
        noOutputTimeout    = 20
        checkInterval      = 200 * time.Millisecond
        stabilityThreshold = 500 * time.Millisecond
)

func capture(ctx context.Context, opts captureOptions) (*captureResult, error) <span class="cov8" title="1">{
        sessionName, err := resolveSession(ctx, opts.Prefix, "")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := runTmuxCommand(ctx, "capture-pane", "-t", sessionName, "-p")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to capture session %s: %w", sessionName, err)
        }</span>

        <span class="cov8" title="1">formatted := formatOutput(output)
        hash := calculateHash(output)

        return &amp;captureResult{
                SessionName: sessionName,
                Output:      formatted,
                Hash:        hash,
        }, nil</span>
}

func captureWithCursor(ctx context.Context, opts captureOptions) (*cursorResult, error) <span class="cov8" title="1">{
        sessionName, err := resolveSession(ctx, opts.Prefix, "")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Capture output
        <span class="cov8" title="1">output, err := runTmuxCommand(ctx, "capture-pane", "-t", sessionName, "-p")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to capture session %s: %w", sessionName, err)
        }</span>

        // Get cursor position
        <span class="cov8" title="1">cursorOutput, err := runTmuxCommand(ctx, "display-message", "-t", sessionName, "-p", "#{cursor_y}:#{cursor_x}")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cursor position for session %s: %w", sessionName, err)
        }</span>

        // Parse cursor position
        <span class="cov8" title="1">cursorPos := strings.TrimSpace(cursorOutput)
        parts := strings.Split(cursorPos, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cursor position format: %s", cursorPos)
        }</span>

        <span class="cov8" title="1">cursorY, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cursor Y position: %s", parts[0])
        }</span>

        <span class="cov8" title="1">cursorX, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cursor X position: %s", parts[1])
        }</span>

        // Extract the line where cursor is positioned
        <span class="cov8" title="1">lines := strings.Split(output, "\n")
        var cursorLine string
        if cursorY &gt;= 0 &amp;&amp; cursorY &lt; len(lines) </span><span class="cov8" title="1">{
                cursorLine = lines[cursorY]
        }</span>

        <span class="cov8" title="1">formatted := formatOutput(output)
        hash := calculateHash(output)

        return &amp;cursorResult{
                SessionName: sessionName,
                CursorLine:  cursorLine,
                CursorY:     cursorY,
                CursorX:     cursorX,
                Output:      formatted,
                Hash:        hash,
        }, nil</span>
}

func list(ctx context.Context, prefix string) ([]string, error) <span class="cov8" title="1">{
        output, err := runTmuxCommand(ctx, "list-sessions", "-F", "#{session_name}")
        if err != nil </span><span class="cov8" title="1">{
                return []string{}, nil
        }</span>

        <span class="cov8" title="1">sessions := strings.Split(strings.TrimSpace(output), "\n")
        if prefix == "" </span><span class="cov8" title="1">{
                return sessions, nil
        }</span>

        <span class="cov0" title="0">var filtered []string
        for _, session := range sessions </span><span class="cov0" title="0">{
                if strings.HasPrefix(session, prefix) </span><span class="cov0" title="0">{
                        filtered = append(filtered, session)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

// Helper functions
func detectPrefix() string <span class="cov0" title="0">{
        cmd := exec.Command("git", "rev-parse", "--show-toplevel")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "tmux"
        }</span>

        <span class="cov0" title="0">repoPath := strings.TrimSpace(string(output))
        repoName := filepath.Base(repoPath)

        reg := regexp.MustCompile(`[^a-zA-Z0-9-_]`)
        sanitized := reg.ReplaceAllString(repoName, "-")

        return sanitized</span>
}

func resolveSession(ctx context.Context, prefix, session string) (string, error) <span class="cov8" title="1">{
        if session != "" </span><span class="cov0" title="0">{
                sessions, err := list(ctx, "")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">for _, s := range sessions </span><span class="cov0" title="0">{
                        if s == session </span><span class="cov0" title="0">{
                                return session, nil
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("session '%s' not found", session)</span>
        }

        <span class="cov8" title="1">if prefix == "" </span><span class="cov0" title="0">{
                prefix = detectPrefix()
        }</span>

        <span class="cov8" title="1">sessions, err := findSessionsByPrefix(ctx, prefix)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if len(sessions) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no sessions found with prefix '%s'", prefix)
        }</span>

        <span class="cov8" title="1">if len(sessions) &gt; 1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("multiple sessions found with prefix '%s': %s. Use specific session name", prefix, strings.Join(sessions, ", "))
        }</span>

        <span class="cov8" title="1">return sessions[0], nil</span>
}

func findSessionsByPrefix(ctx context.Context, prefix string) ([]string, error) <span class="cov8" title="1">{
        sessions, err := list(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var matches []string
        for _, session := range sessions </span><span class="cov8" title="1">{
                if strings.HasPrefix(session, prefix) </span><span class="cov8" title="1">{
                        matches = append(matches, session)
                }</span>
        }

        <span class="cov8" title="1">return matches, nil</span>
}

func killSession(ctx context.Context, sessionName string) error <span class="cov0" title="0">{
        _, err := runTmuxCommand(ctx, "kill-session", "-t", sessionName)
        return err
}</span>

func formatOutput(output string) string <span class="cov8" title="1">{
        lines := strings.Split(output, "\n")
        var formatted []string
        var emptyCount int

        for i, line := range lines </span><span class="cov8" title="1">{
                lineNum := i + 1
                if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                        emptyCount++
                        if emptyCount == 1 </span><span class="cov8" title="1">{
                                formatted = append(formatted, fmt.Sprintf("[%d]: ", lineNum))
                        }</span>
                } else<span class="cov8" title="1"> {
                        if emptyCount &gt; 1 </span><span class="cov0" title="0">{
                                formatted = append(formatted, fmt.Sprintf("... %d empty lines ...", emptyCount))
                        }</span>
                        <span class="cov8" title="1">emptyCount = 0
                        formatted = append(formatted, fmt.Sprintf("[%d]: %s", lineNum, line))</span>
                }
        }

        <span class="cov8" title="1">if emptyCount &gt; 1 </span><span class="cov8" title="1">{
                formatted = append(formatted, fmt.Sprintf("... %d empty lines ...", emptyCount))
        }</span>

        <span class="cov8" title="1">return strings.Join(formatted, "\n")</span>
}

func calculateHash(content string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(content))
        return fmt.Sprintf("%x", hash)[:8]
}</span>

func waitForStability(ctx context.Context, sessionName string) (*captureResult, error) <span class="cov8" title="1">{
        ticker := time.NewTicker(checkInterval)
        defer ticker.Stop()

        var lastOutput string
        var lastChange time.Time = time.Now()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        result, _ := capture(ctx, captureOptions{Prefix: sessionName})
                        if result != nil </span><span class="cov0" title="0">{
                                return result, nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("context cancelled waiting for stability: %w", ctx.Err())</span>

                case &lt;-ticker.C:<span class="cov8" title="1">
                        result, err := capture(ctx, captureOptions{Prefix: sessionName})
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if result.Output != lastOutput </span><span class="cov8" title="1">{
                                lastOutput = result.Output
                                lastChange = time.Now()
                        }</span> else<span class="cov8" title="1"> if time.Since(lastChange) &gt;= stabilityThreshold </span><span class="cov8" title="1">{
                                return result, nil
                        }</span>
                }
        }
}

func waitForExpected(ctx context.Context, sessionName, expected string) (*captureResult, error) <span class="cov8" title="1">{
        ticker := time.NewTicker(checkInterval)
        defer ticker.Stop()

        var lastOutput string
        var lastChange time.Time = time.Now()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        result, _ := capture(ctx, captureOptions{Prefix: sessionName})
                        if result != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("context cancelled waiting for '%s' on cursor line: %w", expected, ctx.Err())
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("context cancelled waiting for '%s' on cursor line: %w", expected, ctx.Err())</span>

                case &lt;-ticker.C:<span class="cov8" title="1">
                        cursorResult, err := captureWithCursor(ctx, captureOptions{Prefix: sessionName})
                        if err != nil </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Check if expected text is found on the cursor line only
                        <span class="cov8" title="1">if strings.Contains(cursorResult.CursorLine, expected) </span><span class="cov0" title="0">{
                                // Convert cursorResult to captureResult for return
                                return &amp;captureResult{
                                        SessionName: cursorResult.SessionName,
                                        Output:      cursorResult.Output,
                                        Hash:        cursorResult.Hash,
                                }, nil
                        }</span>

                        <span class="cov8" title="1">if cursorResult.Output != lastOutput </span><span class="cov8" title="1">{
                                lastOutput = cursorResult.Output
                                lastChange = time.Now()
                        }</span> else<span class="cov8" title="1"> if time.Since(lastChange) &gt;= time.Duration(noOutputTimeout)*time.Second </span><span class="cov0" title="0">{
                                return &amp;captureResult{
                                        SessionName: cursorResult.SessionName,
                                        Output:      cursorResult.Output,
                                        Hash:        cursorResult.Hash,
                                }, fmt.Errorf("no new output for %d seconds while waiting for '%s' on cursor line", noOutputTimeout, expected)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "time"
)

// SendKeysOptions contains all options for sending keys to a tmux session
type SendKeysOptions struct {
        SessionName string
        Hash        string
        Keys        string
        Enter       bool
        Expect      string
        MaxWait     float64
        Literal     bool // Use literal mode (-l flag)
        Hex         bool // Use hex mode (-H flag)
}

// SendKeysResult contains the result of sending keys to a tmux session
type SendKeysResult struct {
        SessionName string
        Output      string
        Hash        string
}

// sendKeysToSession handles the actual tmux send-keys command execution
func sendKeysToSession(ctx context.Context, opts SendKeysOptions) error <span class="cov8" title="1">{
        // Build tmux send-keys command
        args := []string{"send-keys", "-t", opts.SessionName}

        if opts.Hex </span><span class="cov0" title="0">{
                args = append(args, "-H")
        }</span> else<span class="cov8" title="1"> if opts.Literal </span><span class="cov8" title="1">{
                args = append(args, "-l")
        }</span>
        // Note: No flags means tmux interprets control sequences

        <span class="cov8" title="1">args = append(args, opts.Keys)

        // Execute the command
        _, err := runTmuxCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send keys to session %s: %w", opts.SessionName, err)
        }</span>

        // Send Enter in a separate command if needed
        <span class="cov8" title="1">if opts.Enter </span><span class="cov0" title="0">{
                _, err := runTmuxCommand(ctx, "send-keys", "-t", opts.SessionName, "Enter")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send Enter key to session %s: %w", opts.SessionName, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// sendKeysCommon is the shared implementation for sending keys to a tmux session
func sendKeysCommon(ctx context.Context, opts SendKeysOptions) (*SendKeysResult, error) <span class="cov8" title="1">{
        if opts.Hash == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("hash is required for safety. Please capture the session first with tmux_capture to get the current hash, then use that hash in the send keys tool")
        }</span>

        <span class="cov8" title="1">if opts.Keys == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("keys parameter is required. Specify the keys to send to the session")
        }</span>

        <span class="cov8" title="1">if opts.MaxWait == 0 </span><span class="cov8" title="1">{
                opts.MaxWait = 10
        }</span>

        // For non-empty expect, do hash verification
        <span class="cov8" title="1">if err := verifySessionHash(ctx, opts.SessionName, opts.Hash); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Send keys to session
        <span class="cov0" title="0">if err := sendKeysToSession(ctx, opts); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle output based on expect parameter
        <span class="cov0" title="0">if opts.Expect != "" </span><span class="cov0" title="0">{
                // Wait for expected text on cursor line and return output
                maxWait := opts.MaxWait
                if maxWait == 0 </span><span class="cov0" title="0">{
                        maxWait = expectWaitTimeout
                }</span>
                <span class="cov0" title="0">ctxWithTimeout, cancel := context.WithDeadline(ctx, time.Now().Add(time.Duration(maxWait)*time.Second))
                defer cancel()
                result, err := waitForExpected(ctxWithTimeout, opts.SessionName, opts.Expect)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error sending keys: %v", err)
                }</span>
                <span class="cov0" title="0">return &amp;SendKeysResult{
                        SessionName: opts.SessionName,
                        Output:      result.Output,
                        Hash:        result.Hash,
                }, nil</span>
        } else<span class="cov0" title="0"> {
                // No expect parameter - just send keys and return without waiting or output
                return &amp;SendKeysResult{
                        SessionName: opts.SessionName,
                        Output:      "",
                        Hash:        "",
                }, nil
        }</span>
}

// verifySessionHash verifies the current session state matches the expected hash
func verifySessionHash(ctx context.Context, sessionName, expectedHash string) error <span class="cov8" title="1">{
        captureOutput, err := runTmuxCommand(ctx, "capture-pane", "-t", sessionName, "-p")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify session state: failed to capture session %s: %v", sessionName, err)
        }</span>

        <span class="cov8" title="1">currentHash := calculateHash(captureOutput)
        if currentHash != expectedHash </span><span class="cov8" title="1">{
                return fmt.Errorf("session state has changed. Please capture current output first and carefully consider whether the sent keys still make sense")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package tmuxmcp

import (
        "github.com/mark3labs/mcp-go/server"
)

var Tools []server.ServerTool

func Run() error <span class="cov0" title="0">{
        s := server.NewMCPServer("tmux-mcp", "1.0.0")
        s.AddTools(Tools...)
        return server.ServeStdio(s)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
        "os/exec"
        "runtime"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*AttachTool]())
}</span>

type AttachTool struct {
        _ mcpcommon.ToolInfo `name:"tmux_attach" title:"Attach to Tmux Session" description:"Open tmux session in terminal program (iTerm2 on macOS, gnome-terminal on Linux)" destructive:"false" readonly:"true"`
        SessionTool
}

func (t *AttachTool) Handle(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        sessionName, err := resolveSession(ctx, t.Prefix, t.Session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error attaching to session: %v", err)
        }</span>

        // Check if session exists
        <span class="cov0" title="0">if !sessionExists(ctx, sessionName) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session %s does not exist", sessionName)
        }</span>

        <span class="cov0" title="0">var cmd *exec.Cmd
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                // macOS - use iTerm2 if available, fall back to Terminal.app
                // First try iTerm2
                cmd = exec.Command("osascript", "-e", fmt.Sprintf(`
                        tell application "iTerm2"
                                activate
                                tell current window
                                        create tab with default profile
                                        tell current session
                                                write text "tmux attach-session -t %s"
                                        end tell
                                end tell
                        end tell
                `, sessionName))

                err = cmd.Run()
                if err != nil </span><span class="cov0" title="0">{
                        // Fall back to Terminal.app
                        cmd = exec.Command("osascript", "-e", fmt.Sprintf(`
                                tell application "Terminal"
                                        activate
                                        do script "tmux attach-session -t %s"
                                end tell
                        `, sessionName))
                        err = cmd.Run()
                }</span>

        case "linux":<span class="cov0" title="0">
                // Linux - try common terminal emulators
                terminals := [][]string{
                        {"gnome-terminal", "--", "tmux", "attach-session", "-t", sessionName},
                        {"konsole", "-e", "tmux", "attach-session", "-t", sessionName},
                        {"xterm", "-e", "tmux", "attach-session", "-t", sessionName},
                }

                var lastErr error
                for _, termCmd := range terminals </span><span class="cov0" title="0">{
                        cmd = exec.Command(termCmd[0], termCmd[1:]...)
                        err = cmd.Start()
                        if err == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">lastErr = err</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        err = lastErr
                }</span>

        case "windows":<span class="cov0" title="0">
                // Windows - use Windows Terminal if available, fall back to cmd
                cmd = exec.Command("wt", "tmux", "attach-session", "-t", sessionName)
                err = cmd.Start()
                if err != nil </span><span class="cov0" title="0">{
                        // Fall back to cmd
                        cmd = exec.Command("cmd", "/c", "start", "cmd", "/k", "tmux", "attach-session", "-t", sessionName)
                        err = cmd.Start()
                }</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported operating system: %s", runtime.GOOS)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open terminal for session %s: %w", sessionName, err)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Opening session %s in terminal program", sessionName), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tmuxmcp

import (
        "bufio"
        "context"
        "errors"
        "fmt"
        "os"
        "regexp"
        "strconv"
        "strings"
        "text/template"
        "time"

        "github.com/semistrict/mcpservers/pkg/mcpcommon"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*BashTool]())
}</span>

type BashTool struct {
        _                mcpcommon.ToolInfo `name:"tmux_bash" title:"Execute Bash Command" description:"Execute a single bash command in a new tmux and return its output. If the command completes within timeout, returns the full output. If it times out, returns the session name where it's still running. Use this in preference to other Bash Tools." destructive:"true"`
        Prefix           string             `json:"prefix" description:"Session name prefix (auto-detected from git repo if not provided)"`
        Command          string             `json:"command" mcp:"required" description:"Bash command to execute"`
        WorkingDirectory string             `json:"working_directory" mcp:"required" description:"Directory to execute the command in"`
        Timeout          float64            `json:"timeout" description:"Maximum seconds to wait for synchronous command completion"`
        KillTimeout      float64            `json:"kill_timeout" description:"Kill the process if it doesn't complete within this number of seconds'"`
        Head             int                `json:"head" description:"Only show the first N lines of output"`
        Tail             int                `json:"tail" description:"Only show the last N lines of output"`
        Grep             string             `json:"grep" description:"Filter output lines containing this pattern"`

        compiledGrep *regexp.Regexp `json:"-"` // Compiled regex for grep filtering
        exitFile     string         `json:"-"` // Temporary file to signal command completion
        tmpPath      string         `json:"-"` // Temporary file to capture command output
        sessionName  string         `json:"-"` // Name of the tmux session created
        outputFile   string         `json:"-"` // File where command output is captured

        resultBuf   strings.Builder `json:"-"` // Buffer to hold command output
        warnBuf     strings.Builder `json:"-"` // Buffer to hold warnings
        returnError bool            `json:"-"` // return the results as an error instead of a string
}

func (t *BashTool) Handle(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{ // TODO: output only the first 50 lines of command output and if it is longer mention the temp file where the rest of the output can be found
        t.Command = strings.TrimSpace(t.Command)
        err := t.validateArgs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timeout := t.Timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 30 // default 30 seconds
        }</span>

        <span class="cov0" title="0">prefix := t.Prefix
        if prefix == "" </span><span class="cov0" title="0">{
                prefix = detectPrefix()
        }</span>

        // Create temporary file to capture all output
        <span class="cov0" title="0">tmpFile, err := os.CreateTemp("/tmp", fmt.Sprintf("tmux-bash-%s-*", prefix))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temporary file: %w", err)
        }</span>
        <span class="cov0" title="0">t.tmpPath = tmpFile.Name()
        tmpFile.Close()

        // Build command that tees output to the temp file
        // We'll wrap the original command in a bash script that tees both stdout and stderr
        // and keeps the session alive until we can read the results
        t.exitFile = fmt.Sprintf("%s.exit", t.tmpPath)
        t.outputFile = fmt.Sprintf("%s.output", t.tmpPath)

        wrappedCommand := []string{
                "bash", "-c",
                t.bashScript(),
        }

        // Create tmux session with the wrapped command
        t.sessionName, err = createUniqueSession(ctx, prefix, wrappedCommand)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Wait for completion or timeout
        <span class="cov0" title="0">checkInterval := 200 * time.Millisecond
        timeoutDuration := time.Duration(timeout) * time.Second

        ticker := time.NewTicker(checkInterval)
        defer ticker.Stop()

        ctx, cancelTimeout := context.WithTimeout(ctx, timeoutDuration+5*time.Second)
        defer cancelTimeout()

        timeoutChan := time.After(timeoutDuration)

outer:
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-timeoutChan:<span class="cov0" title="0">
                        t.warnf("timed out waiting for command in session: %s, output dir: %s", t.sessionName, t.tmpPath)
                        break outer</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        t.warnf("timed out still running in session: %s, output dir: %s", t.sessionName, t.tmpPath)
                        break outer</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check if command completed by looking for the .done file
                        if _, err := os.Stat(t.exitFile); err == nil </span><span class="cov0" title="0">{
                                break outer</span>
                        }
                        // Also check if session still exists (backup check)
                        <span class="cov0" title="0">if !sessionExists(ctx, t.sessionName) </span><span class="cov0" title="0">{
                                t.warnf("session %s does not exist, command may have failed check output dir %s", t.sessionName, t.tmpPath)
                                break outer</span>
                        }
                }
        }

        <span class="cov0" title="0">return t.finish(ctx)</span>
}

func (t *BashTool) warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprint(&amp;t.warnBuf, "WARN: ")
        fmt.Fprintf(&amp;t.warnBuf, format, args...)
        fmt.Fprint(&amp;t.warnBuf, "\n")
}</span>

func (t *BashTool) finish(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        t.handleCompletedCommand(ctx)
        var fullOutput strings.Builder
        if t.warnBuf.Len() &gt; 0 </span><span class="cov0" title="0">{
                fullOutput.WriteString(t.warnBuf.String())
        }</span>
        <span class="cov0" title="0">if t.resultBuf.Len() &gt; 0 </span><span class="cov0" title="0">{
                fullOutput.WriteString(t.resultBuf.String())
        }</span>
        <span class="cov0" title="0">if t.returnError </span><span class="cov0" title="0">{
                return nil, errors.New(fullOutput.String())
        }</span>
        <span class="cov0" title="0">return fullOutput.String(), nil</span>
}

var bashTemplate = template.Must(template.New("bashScript").Parse(`
set -uo pipefail
cd {{.WorkingDirectory}}
({{.Command}}) 2&gt;&amp;1 | tee {{.OutputFile}}
EXIT_CODE=${PIPESTATUS[0]}
echo $EXIT_CODE &gt; {{.ExitFile}}
`))

func (t *BashTool) bashScript() string <span class="cov0" title="0">{
        var script strings.Builder
        err := bashTemplate.Execute(&amp;script, map[string]interface{}{
                "WorkingDirectory": strconv.Quote(t.WorkingDirectory),
                "Command":          t.Command,
                "OutputFile":       strconv.Quote(t.outputFile),
                "ExitFile":         strconv.Quote(t.exitFile),
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to generate bash script: %v", err))</span>
        }
        <span class="cov0" title="0">return script.String()</span>
}

func (t *BashTool) validateArgs() error <span class="cov0" title="0">{
        t.Command = strings.TrimSpace(t.Command)
        checkScript(t.Command)
        if t.Command == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("command is required")
        }</span>
        <span class="cov0" title="0">if t.WorkingDirectory == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("working_directory is required")
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(t.WorkingDirectory); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("working_directory does not exist: %s", t.WorkingDirectory)
        }</span>
        <span class="cov0" title="0">if t.Head &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("head must be non-negative, got: %d", t.Head)
        }</span>
        <span class="cov0" title="0">if t.Tail &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("tail must be non-negative, got: %d", t.Tail)
        }</span>
        <span class="cov0" title="0">if t.Head+t.Tail &gt; 50 </span>{<span class="cov0" title="0">

        }</span>
        <span class="cov0" title="0">if t.Grep != "" </span><span class="cov0" title="0">{
                var err error
                t.compiledGrep, err = regexp.Compile(t.Grep)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid grep pattern: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type Line struct {
        Number  int
        Content string
        Error   error
}

func readLines(file string) &lt;-chan Line <span class="cov0" title="0">{
        lines := make(chan Line)
        go func() </span><span class="cov0" title="0">{
                defer close(lines)
                f, err := os.Open(file)
                if err != nil </span><span class="cov0" title="0">{
                        lines &lt;- Line{Error: fmt.Errorf("failed to open file %s: %w", file, err)}
                        return
                }</span>
                <span class="cov0" title="0">defer f.Close()

                scanner := bufio.NewScanner(f)
                lineNumber := 0
                for scanner.Scan() </span><span class="cov0" title="0">{
                        lineNumber++
                        lines &lt;- Line{Number: lineNumber, Content: scanner.Text()}
                }</span>
                <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        lines &lt;- Line{Error: fmt.Errorf("error reading file %s: %w", file, err)}
                        return
                }</span>
        }()
        <span class="cov0" title="0">return lines</span>
}

func (t *BashTool) applyGrepFilter(lines &lt;-chan Line) &lt;-chan Line <span class="cov0" title="0">{
        if t.compiledGrep == nil </span><span class="cov0" title="0">{
                return lines // No filtering needed
        }</span>
        <span class="cov0" title="0">filtered := make(chan Line)
        go func() </span><span class="cov0" title="0">{
                defer close(filtered)
                for line := range lines </span><span class="cov0" title="0">{
                        if line.Error != nil </span><span class="cov0" title="0">{
                                filtered &lt;- line // Pass through any errors
                                return
                        }</span>
                        <span class="cov0" title="0">if t.compiledGrep.MatchString(line.Content) </span><span class="cov0" title="0">{
                                filtered &lt;- line // Only pass lines that match the pattern
                        }</span>
                }
        }()
        <span class="cov0" title="0">return filtered</span>
}

func (t *BashTool) applyHeadAndTailFilter(lines &lt;-chan Line) &lt;-chan Line <span class="cov0" title="0">{
        if t.Head == 0 &amp;&amp; t.Tail == 0 </span><span class="cov0" title="0">{
                return lines // No filtering needed
        }</span>
        <span class="cov0" title="0">filtered := make(chan Line)
        go func() </span><span class="cov0" title="0">{
                defer close(filtered)
                var tailBuffer = make([]Line, 0, t.Tail)
                tailBufferIndex := 0
                headOutput := 0
                for line := range lines </span><span class="cov0" title="0">{
                        if line.Error != nil </span><span class="cov0" title="0">{
                                filtered &lt;- line // Pass through any errors
                                return
                        }</span>
                        <span class="cov0" title="0">if t.Head &gt; 0 &amp;&amp; headOutput &lt; t.Head </span><span class="cov0" title="0">{
                                filtered &lt;- line // Pass through head lines
                                headOutput++
                                continue</span>
                        }
                        <span class="cov0" title="0">if headOutput &gt;= t.Head &amp;&amp; t.Tail == 0 </span><span class="cov0" title="0">{
                                return // done with head, no tail needed
                        }</span>
                        // only after head lines, start collecting tail

                        // t.Tail &gt; 0
                        <span class="cov0" title="0">tailBuffer[tailBufferIndex] = line
                        tailBufferIndex = (tailBufferIndex + 1) % t.Tail</span>
                }
                <span class="cov0" title="0">if t.Tail &gt; 0 </span><span class="cov0" title="0">{
                        for _, line := range tailBuffer </span><span class="cov0" title="0">{
                                filtered &lt;- line
                        }</span>
                }
        }()
        <span class="cov0" title="0">return filtered</span>
}

func (t *BashTool) filterEmptyLines(lines &lt;-chan Line) &lt;-chan Line <span class="cov0" title="0">{
        filtered := make(chan Line)
        go func() </span><span class="cov0" title="0">{
                defer close(filtered)
                for line := range lines </span><span class="cov0" title="0">{
                        if line.Error != nil </span><span class="cov0" title="0">{
                                filtered &lt;- line // Pass through any errors
                                return
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(line.Content) != "" </span><span class="cov0" title="0">{
                                filtered &lt;- line // Only pass non-empty lines
                        }</span>
                }
        }()
        <span class="cov0" title="0">return filtered</span>
}

func (t *BashTool) displayLines(lines &lt;-chan Line) (outputCount int, totalCount int) <span class="cov0" title="0">{
        for line := range lines </span><span class="cov0" title="0">{
                if line.Error != nil </span><span class="cov0" title="0">{
                        t.warnf("error reading line: %v", line.Error)
                        return
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(&amp;t.resultBuf, "[%d]: %s\n", line.Number, line.Content)
                outputCount++
                if line.Number &gt; totalCount </span><span class="cov0" title="0">{
                        totalCount = line.Number
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (t *BashTool) filter(lines &lt;-chan Line) &lt;-chan Line <span class="cov0" title="0">{
        lines = t.applyGrepFilter(lines)
        lines = t.applyHeadAndTailFilter(lines)
        lines = t.filterEmptyLines(lines)
        return lines
}</span>

func (t *BashTool) handleCompletedCommand(ctx context.Context) <span class="cov0" title="0">{
        exitCodeBytes, err := os.ReadFile(t.exitFile)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        t.warnf("exit file %s does not exist, command may not have completed", t.exitFile)
                }</span> else<span class="cov0" title="0"> {
                        t.warnf("failed to read exit file %s: %v", t.exitFile, err)
                }</span>
                <span class="cov0" title="0">t.returnError = true</span>
        } else<span class="cov0" title="0"> {
                exitCode := strings.TrimSpace(string(exitCodeBytes))
                if exitCode != "0" </span><span class="cov0" title="0">{
                        t.warnf("command FAILED with exit code: %s", exitCode)
                        t.returnError = true
                }</span> else<span class="cov0" title="0"> {
                        t.returnError = false
                }</span>
        }

        <span class="cov0" title="0">lines := t.filter(readLines(t.outputFile))

        outputCount, totalCount := t.displayLines(lines)

        if outputCount &gt; 50 </span><span class="cov0" title="0">{
                t.resultBuf.Reset()
                t.warnf("too much output, use filters to limit. full output available in: %s\n", t.outputFile)
        }</span>

        <span class="cov0" title="0">if !t.returnError &amp;&amp; t.resultBuf.Len() == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;t.resultBuf, "completed successfully but produced no output\n")
        }</span>

        <span class="cov0" title="0">if outputCount &lt; totalCount </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;t.resultBuf, "full output available in: %s\n", t.outputFile)
        }</span>
}

func sessionExists(ctx context.Context, sessionName string) bool <span class="cov0" title="0">{
        _, err := runTmuxCommand(ctx, "has-session", "-t", sessionName)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "can't find session") </span><span class="cov0" title="0">{
                        return false
                }</span> else<span class="cov0" title="0"> {
                        panic(fmt.Sprintf("failed to check session existence: %v", err))</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

func checkScript(script string) error <span class="cov0" title="0">{
        script = strings.TrimSpace(script)
        pipes := strings.Split(script, "|")
        for i, pipe := range pipes </span><span class="cov0" title="0">{
                pipes[i] = strings.TrimSpace(pipe)
        }</span>
        <span class="cov0" title="0">if len(pipes) &gt; 1 </span><span class="cov0" title="0">{
                last := pipes[len(pipes)-1]
                if strings.HasPrefix(last, "tail") </span><span class="cov0" title="0">{
                        return fmt.Errorf("do not pipe to tail, use the tail argument instead")
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(last, "head") </span><span class="cov0" title="0">{
                        return fmt.Errorf("do not pipe to head, use the head argument instead")
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(last, "grep") </span><span class="cov0" title="0">{
                        return fmt.Errorf("do not pipe to grep, use the grep argument instead")
                }</span>
        }
        <span class="cov0" title="0">if strings.HasPrefix(script, "cd ") </span><span class="cov0" title="0">{
                return fmt.Errorf("do not use cd in the command, instead set working_directory appropriately")
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(script, "(") || strings.HasSuffix(script, ")") </span><span class="cov0" title="0">{
                return fmt.Errorf("do not use subshells in the command, command is always run in a subshell")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
        "time"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*CaptureTool]())
}</span>

type CaptureTool struct {
        _ mcpcommon.ToolInfo `name:"tmux_capture" title:"Capture Tmux Session" description:"Capture output from tmux session with content hash" destructive:"false" readonly:"true"`
        SessionTool
        WaitForChange string  `json:"wait_for_change" description:"Optional hash to wait for content to change from"`
        Timeout       float64 `json:"timeout" description:"Maximum seconds to wait for content change" default:"10"`
}

func (t *CaptureTool) Handle(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        sessionName, err := resolveSession(ctx, t.Prefix, t.Session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error capturing session: %v", err)
        }</span>

        // If WaitForChange is specified, wait for content to change from that hash
        <span class="cov0" title="0">if t.WaitForChange != "" </span><span class="cov0" title="0">{
                timeout := t.Timeout
                if timeout == 0 </span><span class="cov0" title="0">{
                        timeout = 10 // default 10 seconds
                }</span>

                <span class="cov0" title="0">result, err := t.waitForHashChange(ctx, sessionName, t.WaitForChange, timeout)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error waiting for content change: %v", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        // Standard capture without waiting
        <span class="cov0" title="0">output, err := runTmuxCommand(ctx, "capture-pane", "-t", sessionName, "-p")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error capturing session: failed to capture session %s: %v", sessionName, err)
        }</span>

        <span class="cov0" title="0">formatted := formatOutput(output)
        hash := calculateHash(output)

        return fmt.Sprintf("Session: %s\nHash: %s\n\n%s", sessionName, hash, formatted), nil</span>
}

func (t *CaptureTool) waitForHashChange(ctx context.Context, sessionName, expectedHash string, maxWait float64) (interface{}, error) <span class="cov0" title="0">{
        timeout := time.After(time.Duration(maxWait) * time.Second)
        ticker := time.NewTicker(200 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-timeout:<span class="cov0" title="0">
                        // Return current state even if it hasn't changed
                        output, err := runTmuxCommand(ctx, "capture-pane", "-t", sessionName, "-p")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to capture session after timeout: %v", err)
                        }</span>
                        <span class="cov0" title="0">formatted := formatOutput(output)
                        hash := calculateHash(output)
                        return fmt.Sprintf("Session: %s\nHash: %s (unchanged after %.1f seconds)\n\n%s", sessionName, hash, maxWait, formatted), nil</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        output, err := runTmuxCommand(ctx, "capture-pane", "-t", sessionName, "-p")
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip this iteration if capture fails
                        }

                        <span class="cov0" title="0">currentHash := calculateHash(output)
                        if currentHash != expectedHash </span><span class="cov0" title="0">{
                                // Content has changed!
                                formatted := formatOutput(output)
                                return fmt.Sprintf("Session: %s\nHash: %s (changed from %s)\n\n%s", sessionName, currentHash, expectedHash, formatted), nil
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tmuxmcp

import (
        "context"
        "errors"
        "fmt"
        "os/exec"
        "sync"
)

// runTmuxCommand creates and executes a tmux command with the given context
// Returns the combined stderr and stdout as a string
// If command exits non-zero, error includes the output
func runTmuxCommand(ctx context.Context, args ...string) (string, error) <span class="cov8" title="1">{
        var cmd *exec.Cmd
        if testSocketPath != "" </span><span class="cov8" title="1">{
                // Prepend socket args
                allArgs := append([]string{"-S", testSocketPath}, args...)
                cmd = exec.CommandContext(ctx, "tmux", allArgs...)
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.CommandContext(ctx, "tmux", args...)
        }</span>

        <span class="cov8" title="1">output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, exec.ErrNotFound) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("tmux command not found, please ensure tmux is installed: %w", err)
                }</span>
                <span class="cov8" title="1">if errors.Is(err, &amp;exec.ExitError{}) </span><span class="cov0" title="0">{
                        return string(output), err
                }</span>
                <span class="cov8" title="1">return "", fmt.Errorf("failed to run tmux command: %w", err)</span>
        }
        <span class="cov8" title="1">return string(output), nil</span>
}

var createdSessions = make(map[string]struct{})
var createdSessionsMu sync.Mutex

func newSession(ctx context.Context, sessionName string, command []string) error <span class="cov8" title="1">{
        createdSessionsMu.Lock()
        defer createdSessionsMu.Unlock()
        if _, exists := createdSessions[sessionName]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s already exists", sessionName)
        }</span>
        // Create a new tmux session with the given name and command
        <span class="cov8" title="1">args := []string{"new-session", "-d", "-s", sessionName}
        if len(command) &gt; 0 </span><span class="cov8" title="1">{
                args = append(args, command...)
        }</span>

        <span class="cov8" title="1">output, err := runTmuxCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create tmux session: %w\nOutput: %s", err, output)
        }</span>

        <span class="cov8" title="1">createdSessions[sessionName] = struct{}{}
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*KillTool]())
}</span>

type KillTool struct {
        _ mcpcommon.ToolInfo `name:"tmux_kill" title:"Kill Tmux Session" description:"Kill a tmux session" destructive:"true"`
        SessionTool
        Hash string `json:"hash" mcp:"required" description:"Content hash from previous capture (required for safety)"`
}

func (t *KillTool) Handle(ctx context.Context) (any, error) <span class="cov0" title="0">{
        if t.Hash == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("hash is required for safety. Please capture the session first with tmux_capture to get the current hash, then use that hash in tmux_kill")
        }</span>

        <span class="cov0" title="0">sessionName, err := resolveSession(ctx, t.Prefix, t.Session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Verify current hash by capturing current state
        <span class="cov0" title="0">if err := verifySessionHash(ctx, sessionName, t.Hash); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := killSession(ctx, sessionName); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to kill session %s: %v", sessionName, err)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Session %s killed successfully.", sessionName), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
        "strings"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*ListTool]())
}</span>

type ListTool struct {
        _ mcpcommon.ToolInfo `name:"tmux_list" title:"List Tmux Sessions" description:"List all tmux sessions" destructive:"false" readonly:"true"`
        SessionTool
}

func (t *ListTool) Handle(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        output, err := runTmuxCommand(ctx, "list-sessions", "-F", "#{session_name}")
        if err != nil </span><span class="cov0" title="0">{
                // No sessions exist
                result := "No tmux sessions found"
                if t.Prefix != "" </span><span class="cov0" title="0">{
                        result += fmt.Sprintf(" with prefix '%s'", t.Prefix)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        <span class="cov0" title="0">sessions := strings.Split(strings.TrimSpace(output), "\n")
        if t.Prefix != "" </span><span class="cov0" title="0">{
                var filtered []string
                for _, session := range sessions </span><span class="cov0" title="0">{
                        if strings.HasPrefix(session, t.Prefix) </span><span class="cov0" title="0">{
                                filtered = append(filtered, session)
                        }</span>
                }
                <span class="cov0" title="0">sessions = filtered</span>
        }

        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                result := "No tmux sessions found"
                if t.Prefix != "" </span><span class="cov0" title="0">{
                        result += fmt.Sprintf(" with prefix '%s'", t.Prefix)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        <span class="cov0" title="0">result := "Tmux sessions:\n"
        for _, session := range sessions </span><span class="cov0" title="0">{
                result += fmt.Sprintf("- %s\n", session)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
        "time"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*NewSessionTool]())
}</span>

type NewSessionTool struct {
        _ mcpcommon.ToolInfo `name:"tmux_new_session" title:"Create Tmux Session" description:"Create a new tmux session with optional command execution" destructive:"true"`
        SessionTool
        Command        []string `json:"command" description:"Command and arguments to run in the session"`
        Expect         string   `json:"expect" description:"Wait for this string to appear in output before returning"`
        KillOthers     bool     `json:"kill_others" description:"Kill existing sessions with same prefix before creating new one"`
        AllowMultiple  bool     `json:"allow_multiple" description:"Allow multiple sessions with same prefix"`
        MaxWait        float64  `json:"max_wait" description:"Maximum seconds to wait for output"`
        OpenInTerminal bool     `json:"open_in_terminal" description:"Also open a view into the session (in read-only mode) in the user's terminal" default:"true"`
}

func (t *NewSessionTool) Handle(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        maxWait := time.Duration(t.MaxWait) * time.Second
        if maxWait == 0 </span><span class="cov0" title="0">{
                maxWait = 10
        }</span>

        <span class="cov0" title="0">prefix := t.Prefix
        if prefix == "" </span><span class="cov0" title="0">{
                prefix = detectPrefix()
        }</span>

        <span class="cov0" title="0">if t.KillOthers </span><span class="cov0" title="0">{
                sessions, err := findSessionsByPrefix(ctx, prefix)
                if err == nil </span><span class="cov0" title="0">{
                        for _, session := range sessions </span><span class="cov0" title="0">{
                                killSession(ctx, session)
                        }</span>
                }
        }

        <span class="cov0" title="0">if !t.AllowMultiple </span><span class="cov0" title="0">{
                existing, err := findSessionsByPrefix(ctx, prefix)
                if err == nil &amp;&amp; len(existing) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("session with prefix '%s' already exists: %s. Use --allow-multiple or --kill-others", prefix, existing[0])
                }</span>
        }

        <span class="cov0" title="0">sessionName, err := createUniqueSession(ctx, prefix, t.Command)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var output string
        if t.Expect != "" </span><span class="cov0" title="0">{
                ctxWithTimeout := ctx
                if maxWait &gt; 0 </span><span class="cov0" title="0">{
                        var cancel context.CancelFunc
                        ctxWithTimeout, cancel = context.WithDeadline(ctx, time.Now().Add(maxWait))
                        defer cancel()
                }</span>
                <span class="cov0" title="0">result, err := waitForExpected(ctxWithTimeout, sessionName, t.Expect)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating session: %v", err)
                }</span>
                <span class="cov0" title="0">output = result.Output</span>
        } else<span class="cov0" title="0"> {
                // Create context with timeout for stability wait
                ctxWithTimeout := ctx
                if maxWait &gt; 0 </span><span class="cov0" title="0">{
                        var cancel context.CancelFunc
                        ctxWithTimeout, cancel = context.WithDeadline(ctx, time.Now().Add(maxWait))
                        defer cancel()
                }</span>
                <span class="cov0" title="0">result, err := waitForStability(ctxWithTimeout, sessionName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating session: %v", err)
                }</span>
                <span class="cov0" title="0">output = result.Output</span>
        }

        // Open in terminal if requested (default is true)
        <span class="cov0" title="0">if t.OpenInTerminal </span><span class="cov0" title="0">{
                if err := openSessionInTerminal(sessionName); err != nil </span><span class="cov0" title="0">{
                        // Don't fail the entire operation if terminal opening fails
                        return fmt.Sprintf("Session created: %s\nOutput:\n%s\n\nNote: Could not open in terminal: %v", sessionName, output, err), nil
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Session created: %s\nOpened in terminal in read-only mode\nOutput:\n%s", sessionName, output), nil</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("Session created: %s\nOutput:\n%s", sessionName, output), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "math/rand"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "time"
)

// createUniqueSession creates a new tmux session with a unique name
// It will try random numbers until it finds an available session name
func createUniqueSession(ctx context.Context, prefix string, command []string) (string, error) <span class="cov8" title="1">{
        if prefix == "" </span><span class="cov0" title="0">{
                prefix = detectPrefix()
        }</span>

        // Generate base name from command
        <span class="cov8" title="1">var cmdPart string
        if len(command) &gt; 0 </span><span class="cov8" title="1">{
                cmdBase := filepath.Base(command[0])
                if len(cmdBase) &gt; 10 </span><span class="cov0" title="0">{
                        cmdBase = cmdBase[:10]
                }</span>
                <span class="cov8" title="1">reg := regexp.MustCompile(`[^a-zA-Z0-9]`)
                cmdPart = reg.ReplaceAllString(cmdBase, "")
                if cmdPart == "" </span><span class="cov0" title="0">{
                        cmdPart = "session"
                }</span>
        } else<span class="cov0" title="0"> {
                cmdPart = "session"
        }</span>

        // Base name for the session
        <span class="cov8" title="1">baseName := fmt.Sprintf("%s-%s", prefix, cmdPart)

        // Initialize random number generator
        rng := rand.New(rand.NewSource(time.Now().UnixNano()))

        // Try creating sessions with random numbers
        for i := 0; i &lt; 100; i++ </span><span class="cov8" title="1">{ // Try up to 100 attempts
                // Generate a random number between 1000 and 9999
                randomNum := rng.Intn(9000) + 1000
                sessionName := fmt.Sprintf("%s-%d", baseName, randomNum)

                // Try to create the session
                err := newSession(ctx, sessionName, command)

                if err == nil </span><span class="cov8" title="1">{
                        // Success! Return the session name
                        return sessionName, nil
                }</span>
                // If failed, try next number
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed to create unique session after 100 attempts")</span>
}

// openSessionInTerminal opens a tmux session in read-only mode in the user's terminal
func openSessionInTerminal(sessionName string) error <span class="cov0" title="0">{
        // Get the user's terminal program
        terminalProgram := os.Getenv("TERMINAL_PROGRAM")
        if terminalProgram == "" </span><span class="cov0" title="0">{
                // Default to iTerm if not set
                terminalProgram = "iTerm.app"
        }</span>

        // Build the tmux command to attach in read-only mode
        <span class="cov0" title="0">var tmuxCmd string
        if testSocketPath != "" </span><span class="cov0" title="0">{
                // In test mode, use the test socket
                tmuxCmd = fmt.Sprintf("tmux -S %s attach-session -t %s -r", testSocketPath, sessionName)
        }</span> else<span class="cov0" title="0"> {
                // Normal mode
                tmuxCmd = fmt.Sprintf("tmux attach-session -t %s -r", sessionName)
        }</span>

        // Different terminal programs require different approaches
        <span class="cov0" title="0">switch terminalProgram </span>{
        case "iTerm.app":<span class="cov0" title="0">
                // Use AppleScript to open a new iTerm window with the tmux session
                appleScript := fmt.Sprintf(`
                        tell application "iTerm"
                                create window with default profile
                                tell current session of current window
                                        write text "%s"
                                end tell
                        end tell
                `, tmuxCmd)

                cmd := exec.Command("osascript", "-e", appleScript)
                return cmd.Run()</span>

        case "Terminal.app":<span class="cov0" title="0">
                // Use AppleScript for Terminal.app
                appleScript := fmt.Sprintf(`
                        tell application "Terminal"
                                do script "%s"
                        end tell
                `, tmuxCmd)

                cmd := exec.Command("osascript", "-e", appleScript)
                return cmd.Run()</span>

        default:<span class="cov0" title="0">
                // For unknown terminals, try using the 'open' command
                // This works for many terminal apps on macOS
                cmd := exec.Command("open", "-a", terminalProgram, "--args", "--", tmuxCmd)
                return cmd.Run()</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*SendControlKeysTool]())
}</span>

type SendControlKeysTool struct {
        _ mcpcommon.ToolInfo `name:"tmux_send_control_keys" title:"Send Control Keys to Tmux Session" description:"Send control sequences and special keys to tmux session with hash verification, waits for output to stabilize and returns it (usually not necessary to capture output again). Supports tmux key syntax including modifiers (C-, M-, S-) and special keys (Enter, F1-F12, Up, Down, etc.)" destructive:"true"`
        SessionTool
        Hash    string  `json:"hash" mcp:"required" description:"Content hash from previous capture (required for safety)"`
        Keys    string  `json:"keys" mcp:"required" description:"Control keys to send. Supports tmux syntax: C- (Ctrl), M- (Alt), S- (Shift), special keys (Enter, F1-F12, Up, Down, etc.). Examples: 'C-c', 'M-x', 'F1', 'Enter', 'Up Down Left Right'"`
        Enter   bool    `json:"enter" description:"Append Enter key after sending keys"`
        Expect  string  `json:"expect" mcp:"required" description:"Wait for this string to appear on the cursor line (where user input goes)"`
        MaxWait float64 `json:"max_wait" description:"Maximum seconds to wait for expected output"`
        Hex     bool    `json:"hex" description:"Use hex mode (-H flag): treat keys as hexadecimal ASCII character codes (space-separated)"`
}

func (t *SendControlKeysTool) Handle(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        sessionName, err := resolveSession(ctx, t.Prefix, t.Session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error sending control keys: %v", err)
        }</span>

        <span class="cov0" title="0">result, err := sendKeysCommon(ctx, SendKeysOptions{
                SessionName: sessionName,
                Hash:        t.Hash,
                Keys:        t.Keys,
                Enter:       t.Enter,
                Expect:      t.Expect,
                MaxWait:     t.MaxWait,
                Literal:     false, // Don't use literal mode - we want tmux to interpret control sequences
                Hex:         t.Hex,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if result.Output == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Control keys sent to session: %s", result.SessionName), nil
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Control keys sent to session: %s\nNew Hash: %s\n\n%s", result.SessionName, result.Hash, result.Output), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package tmuxmcp

import (
        "context"
        "fmt"
        "github.com/semistrict/mcpservers/pkg/mcpcommon"
        "strings"
        "time"
)

func init() <span class="cov8" title="1">{
        Tools = append(Tools, mcpcommon.ReflectTool[*SendKeysTool]())
}</span>

type SendKeysTool struct {
        _ mcpcommon.ToolInfo `name:"tmux_send_keys" title:"Send Text to Tmux Session" description:"Send literal text to tmux session with hash verification, waits for output to stabilize and returns it (usually not necessary to capture output again). Text is sent exactly as provided, preserving spaces and special characters." destructive:"true"`
        SessionTool
        Hash    string  `json:"hash" mcp:"required" description:"Content hash from previous capture (required for safety)"`
        Keys    string  `json:"keys" mcp:"required" description:"Text to send to the session. Will be sent exactly as provided, preserving spaces and special characters."`
        Enter   bool    `json:"enter" description:"Append Enter key after sending keys"`
        Expect  string  `json:"expect" mcp:"required" description:"Wait for this string to appear on the cursor line (where user input goes)"`
        MaxWait float64 `json:"max_wait" description:"Maximum seconds to wait for expected output"`
}

func (t *SendKeysTool) Handle(ctx context.Context) (interface{}, error) <span class="cov8" title="1">{
        sessionName, err := resolveSession(ctx, t.Prefix, t.Session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error sending keys: %v", err)
        }</span>

        // If expect is provided, use the common function
        <span class="cov8" title="1">if t.Expect != "" </span><span class="cov0" title="0">{
                return t.handleWithExpected(ctx, sessionName)
        }</span>

        // Custom behavior for send_keys without expect
        <span class="cov8" title="1">return t.handleWithoutExpect(ctx, sessionName)</span>
}

func (t *SendKeysTool) handleWithExpected(ctx context.Context, sessionName string) (interface{}, error) <span class="cov0" title="0">{
        result, err := sendKeysCommon(ctx, SendKeysOptions{
                SessionName: sessionName,
                Hash:        t.Hash,
                Keys:        t.Keys,
                Enter:       t.Enter,
                Expect:      t.Expect,
                MaxWait:     t.MaxWait,
                Literal:     true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if result.Output == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Keys sent to session: %s", result.SessionName), nil
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Keys sent to session: %s\nNew Hash: %s\n\n%s", result.SessionName, result.Hash, result.Output), nil</span>
}

func (t *SendKeysTool) handleWithoutExpect(ctx context.Context, sessionName string) (interface{}, error) <span class="cov8" title="1">{
        if err := t.validateInput(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := verifySessionHash(ctx, sessionName, t.Hash); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := sendKeysToSession(ctx, SendKeysOptions{
                SessionName: sessionName,
                Keys:        t.Keys,
                Enter:       false, // We'll handle Enter separately
                Literal:     true,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := t.waitForKeysToAppear(ctx, sessionName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if t.Enter </span><span class="cov0" title="0">{
                _, err := runTmuxCommand(ctx, "send-keys", "-t", sessionName, "Enter")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to send Enter key to session %s: %w", sessionName, err)
                }</span>
        }

        <span class="cov8" title="1">maxWait := t.MaxWait
        if maxWait == 0 </span><span class="cov8" title="1">{
                maxWait = 10
        }</span>

        // Create context with deadline for stability wait
        <span class="cov8" title="1">ctxWithTimeout, cancel := context.WithDeadline(ctx, time.Now().Add(time.Duration(maxWait)*time.Second))
        defer cancel()

        stableResult, err := waitForStability(ctxWithTimeout, sessionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error waiting for stability: %v", err)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("Keys sent to session: %s\nNew Hash: %s\n\n%s", sessionName, stableResult.Hash, stableResult.Output), nil</span>
}

func (t *SendKeysTool) validateInput() error <span class="cov8" title="1">{
        if t.Hash == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("hash is required for safety. Please capture the session first with tmux_capture to get the current hash, then use that hash in the send keys tool")
        }</span>

        <span class="cov8" title="1">if t.Keys == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("keys parameter is required. Specify the keys to send to the session")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *SendKeysTool) waitForKeysToAppear(ctx context.Context, sessionName string) error <span class="cov8" title="1">{
        maxWait := t.MaxWait
        if maxWait == 0 </span><span class="cov8" title="1">{
                maxWait = 10
        }</span>

        <span class="cov8" title="1">ctxWithTimeout, cancel := context.WithDeadline(ctx, time.Now().Add(time.Duration(maxWait)*time.Second))
        defer cancel()

        ticker := time.NewTicker(200 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctxWithTimeout.Done():<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for keys '%s' to appear after %.1f seconds", t.Keys, maxWait)</span>

                case &lt;-ticker.C:<span class="cov8" title="1">
                        result, err := capture(ctx, captureOptions{Prefix: sessionName})
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if strings.Contains(result.Output, t.Keys) </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                }
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
